// This file is @generated by prost-build.
/// Login response data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponseData {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidationParam {
    #[prost(oneof = "validation_param::Param", tags = "1, 2")]
    pub param: ::core::option::Option<validation_param::Param>,
}
/// Nested message and enum types in `ValidationParam`.
pub mod validation_param {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Param {
        #[prost(uint32, tag = "1")]
        Min(u32),
        #[prost(uint32, tag = "2")]
        Max(u32),
    }
}
/// Error details for validation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationErrorData {
    #[prost(enumeration = "FieldType", tag = "1")]
    pub field: i32,
    #[prost(enumeration = "ValidationErrorCode", repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<i32>,
}
/// Counter data
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CounterData {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiData {
    #[prost(oneof = "api_data::Data", tags = "1, 3")]
    pub data: ::core::option::Option<api_data::Data>,
}
/// Nested message and enum types in `ApiData`.
pub mod api_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        LoginResponse(super::LoginResponseData),
        /// ValidationErrorData validation_error = 2;
        #[prost(message, tag = "3")]
        CounterData(super::CounterData),
    }
}
/// Generic API response wrapper
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiResponse {
    #[prost(enumeration = "ResponseCode", tag = "2")]
    pub code: i32,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<ApiData>,
}
/// Registration request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistrationRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
/// Login request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
/// Email verification request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmailVerificationRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// Set counter request
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCounterRequest {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// Password reset request (initial step)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResetRequest {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// Password reset completion request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResetCompleteRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_password: ::prost::alloc::string::String,
}
/// API Response Codes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResponseCode {
    Unspecified = 0,
    /// Success codes
    Success = 1,
    /// Error codes
    ErrorInvalidInput = 100,
    ErrorUsernameTaken = 101,
    ErrorInvalidCredentials = 102,
    ErrorEmailNotVerified = 103,
    ErrorInvalidToken = 104,
    ErrorDatabase = 105,
    ErrorInternal = 106,
    ErrorValidation = 107,
}
impl ResponseCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESPONSE_CODE_UNSPECIFIED",
            Self::Success => "SUCCESS",
            Self::ErrorInvalidInput => "ERROR_INVALID_INPUT",
            Self::ErrorUsernameTaken => "ERROR_USERNAME_TAKEN",
            Self::ErrorInvalidCredentials => "ERROR_INVALID_CREDENTIALS",
            Self::ErrorEmailNotVerified => "ERROR_EMAIL_NOT_VERIFIED",
            Self::ErrorInvalidToken => "ERROR_INVALID_TOKEN",
            Self::ErrorDatabase => "ERROR_DATABASE",
            Self::ErrorInternal => "ERROR_INTERNAL",
            Self::ErrorValidation => "ERROR_VALIDATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESPONSE_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS" => Some(Self::Success),
            "ERROR_INVALID_INPUT" => Some(Self::ErrorInvalidInput),
            "ERROR_USERNAME_TAKEN" => Some(Self::ErrorUsernameTaken),
            "ERROR_INVALID_CREDENTIALS" => Some(Self::ErrorInvalidCredentials),
            "ERROR_EMAIL_NOT_VERIFIED" => Some(Self::ErrorEmailNotVerified),
            "ERROR_INVALID_TOKEN" => Some(Self::ErrorInvalidToken),
            "ERROR_DATABASE" => Some(Self::ErrorDatabase),
            "ERROR_INTERNAL" => Some(Self::ErrorInternal),
            "ERROR_VALIDATION" => Some(Self::ErrorValidation),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldType {
    Unspecified = 0,
    Username = 1,
    Email = 2,
    Password = 3,
}
impl FieldType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FIELD_TYPE_UNSPECIFIED",
            Self::Username => "USERNAME",
            Self::Email => "EMAIL",
            Self::Password => "PASSWORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIELD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "USERNAME" => Some(Self::Username),
            "EMAIL" => Some(Self::Email),
            "PASSWORD" => Some(Self::Password),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValidationErrorCode {
    Unspecified = 0,
    Required = 1,
    TooShort = 2,
    TooLong = 3,
    InvalidCharacters = 4,
    InvalidFormat = 5,
    TooFewUppercaseLetters = 6,
    TooFewLowercaseLetters = 7,
    TooFewDigits = 8,
    TooFewSpecialCharacters = 9,
    Mismatch = 10,
}
impl ValidationErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VALIDATION_ERROR_CODE_UNSPECIFIED",
            Self::Required => "REQUIRED",
            Self::TooShort => "TOO_SHORT",
            Self::TooLong => "TOO_LONG",
            Self::InvalidCharacters => "INVALID_CHARACTERS",
            Self::InvalidFormat => "INVALID_FORMAT",
            Self::TooFewUppercaseLetters => "TOO_FEW_UPPERCASE_LETTERS",
            Self::TooFewLowercaseLetters => "TOO_FEW_LOWERCASE_LETTERS",
            Self::TooFewDigits => "TOO_FEW_DIGITS",
            Self::TooFewSpecialCharacters => "TOO_FEW_SPECIAL_CHARACTERS",
            Self::Mismatch => "MISMATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALIDATION_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "REQUIRED" => Some(Self::Required),
            "TOO_SHORT" => Some(Self::TooShort),
            "TOO_LONG" => Some(Self::TooLong),
            "INVALID_CHARACTERS" => Some(Self::InvalidCharacters),
            "INVALID_FORMAT" => Some(Self::InvalidFormat),
            "TOO_FEW_UPPERCASE_LETTERS" => Some(Self::TooFewUppercaseLetters),
            "TOO_FEW_LOWERCASE_LETTERS" => Some(Self::TooFewLowercaseLetters),
            "TOO_FEW_DIGITS" => Some(Self::TooFewDigits),
            "TOO_FEW_SPECIAL_CHARACTERS" => Some(Self::TooFewSpecialCharacters),
            "MISMATCH" => Some(Self::Mismatch),
            _ => None,
        }
    }
}
/// Password strength levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PasswordStrength {
    Unspecified = 0,
    Weak = 1,
    Medium = 2,
    Strong = 3,
    Cia = 4,
}
impl PasswordStrength {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PASSWORD_STRENGTH_UNSPECIFIED",
            Self::Weak => "PASSWORD_STRENGTH_WEAK",
            Self::Medium => "PASSWORD_STRENGTH_MEDIUM",
            Self::Strong => "PASSWORD_STRENGTH_STRONG",
            Self::Cia => "PASSWORD_STRENGTH_CIA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PASSWORD_STRENGTH_UNSPECIFIED" => Some(Self::Unspecified),
            "PASSWORD_STRENGTH_WEAK" => Some(Self::Weak),
            "PASSWORD_STRENGTH_MEDIUM" => Some(Self::Medium),
            "PASSWORD_STRENGTH_STRONG" => Some(Self::Strong),
            "PASSWORD_STRENGTH_CIA" => Some(Self::Cia),
            _ => None,
        }
    }
}
