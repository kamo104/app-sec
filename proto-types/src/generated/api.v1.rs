// This file is @generated by prost-build.
/// Login response data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponseData {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    /// Unix timestamp in seconds
    #[prost(int64, tag = "3")]
    pub session_expires_at: i64,
    /// Unix timestamp in seconds
    #[prost(int64, tag = "4")]
    pub session_created_at: i64,
}
/// Counter data
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CounterData {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiData {
    #[prost(oneof = "api_data::Data", tags = "1, 2, 3")]
    pub data: ::core::option::Option<api_data::Data>,
}
/// Nested message and enum types in `ApiData`.
pub mod api_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "1")]
        LoginResponse(super::LoginResponseData),
        #[prost(message, tag = "2")]
        ValidationError(super::ValidationErrorData),
        #[prost(message, tag = "3")]
        CounterData(super::CounterData),
    }
}
/// Generic API response wrapper
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiResponse {
    #[prost(enumeration = "ResponseCode", tag = "1")]
    pub code: i32,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<ApiData>,
    #[prost(oneof = "api_response::Detail", tags = "2, 3")]
    pub detail: ::core::option::Option<api_response::Detail>,
}
/// Nested message and enum types in `ApiResponse`.
pub mod api_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        #[prost(enumeration = "super::SuccessCode", tag = "2")]
        Success(i32),
        #[prost(enumeration = "super::ErrorCode", tag = "3")]
        Error(i32),
    }
}
/// Registration request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistrationRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
/// Login request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
/// Email verification request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmailVerificationRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// Set counter request
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCounterRequest {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// Password reset request (initial step)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResetRequest {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// Password reset completion request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResetCompleteRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_password: ::prost::alloc::string::String,
}
/// Error details for validation - single field
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationFieldError {
    #[prost(enumeration = "FieldType", tag = "1")]
    pub field: i32,
    #[prost(enumeration = "ValidationErrorCode", repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<i32>,
}
/// Error details for validation - multiple fields
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationErrorData {
    #[prost(message, repeated, tag = "1")]
    pub field_errors: ::prost::alloc::vec::Vec<ValidationFieldError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationDetailedPasswordData {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ValidationFieldError>,
    #[prost(enumeration = "PasswordStrength", tag = "2")]
    pub strength: i32,
    #[prost(uint32, tag = "3")]
    pub score: u32,
}
/// Top-level response status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResponseCode {
    Unspecified = 0,
    Success = 1,
    Error = 2,
}
impl ResponseCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESPONSE_CODE_UNSPECIFIED",
            Self::Success => "SUCCESS",
            Self::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESPONSE_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS" => Some(Self::Success),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Success codes - specific success outcomes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SuccessCode {
    Unspecified = 0,
    SuccessOk = 1,
    SuccessRegistered = 2,
    SuccessLoggedIn = 3,
    SuccessLoggedOut = 4,
    SuccessEmailVerified = 5,
    SuccessSessionRefreshed = 6,
    SuccessPasswordResetRequested = 7,
    SuccessPasswordResetCompleted = 8,
    SuccessCounterUpdated = 9,
}
impl SuccessCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUCCESS_CODE_UNSPECIFIED",
            Self::SuccessOk => "SUCCESS_OK",
            Self::SuccessRegistered => "SUCCESS_REGISTERED",
            Self::SuccessLoggedIn => "SUCCESS_LOGGED_IN",
            Self::SuccessLoggedOut => "SUCCESS_LOGGED_OUT",
            Self::SuccessEmailVerified => "SUCCESS_EMAIL_VERIFIED",
            Self::SuccessSessionRefreshed => "SUCCESS_SESSION_REFRESHED",
            Self::SuccessPasswordResetRequested => "SUCCESS_PASSWORD_RESET_REQUESTED",
            Self::SuccessPasswordResetCompleted => "SUCCESS_PASSWORD_RESET_COMPLETED",
            Self::SuccessCounterUpdated => "SUCCESS_COUNTER_UPDATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUCCESS_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS_OK" => Some(Self::SuccessOk),
            "SUCCESS_REGISTERED" => Some(Self::SuccessRegistered),
            "SUCCESS_LOGGED_IN" => Some(Self::SuccessLoggedIn),
            "SUCCESS_LOGGED_OUT" => Some(Self::SuccessLoggedOut),
            "SUCCESS_EMAIL_VERIFIED" => Some(Self::SuccessEmailVerified),
            "SUCCESS_SESSION_REFRESHED" => Some(Self::SuccessSessionRefreshed),
            "SUCCESS_PASSWORD_RESET_REQUESTED" => {
                Some(Self::SuccessPasswordResetRequested)
            }
            "SUCCESS_PASSWORD_RESET_COMPLETED" => {
                Some(Self::SuccessPasswordResetCompleted)
            }
            "SUCCESS_COUNTER_UPDATED" => Some(Self::SuccessCounterUpdated),
            _ => None,
        }
    }
}
/// Error codes - specific error types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    Unspecified = 0,
    InvalidInput = 1,
    UsernameTaken = 2,
    InvalidCredentials = 3,
    EmailNotVerified = 4,
    InvalidToken = 5,
    Database = 6,
    Internal = 7,
    Validation = 8,
    EmailTaken = 9,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_CODE_UNSPECIFIED",
            Self::InvalidInput => "INVALID_INPUT",
            Self::UsernameTaken => "USERNAME_TAKEN",
            Self::InvalidCredentials => "INVALID_CREDENTIALS",
            Self::EmailNotVerified => "EMAIL_NOT_VERIFIED",
            Self::InvalidToken => "INVALID_TOKEN",
            Self::Database => "DATABASE",
            Self::Internal => "INTERNAL",
            Self::Validation => "VALIDATION",
            Self::EmailTaken => "EMAIL_TAKEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "INVALID_INPUT" => Some(Self::InvalidInput),
            "USERNAME_TAKEN" => Some(Self::UsernameTaken),
            "INVALID_CREDENTIALS" => Some(Self::InvalidCredentials),
            "EMAIL_NOT_VERIFIED" => Some(Self::EmailNotVerified),
            "INVALID_TOKEN" => Some(Self::InvalidToken),
            "DATABASE" => Some(Self::Database),
            "INTERNAL" => Some(Self::Internal),
            "VALIDATION" => Some(Self::Validation),
            "EMAIL_TAKEN" => Some(Self::EmailTaken),
            _ => None,
        }
    }
}
/// ------ VALIDATION ------
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldType {
    Unspecified = 0,
    Username = 1,
    Email = 2,
    Password = 3,
}
impl FieldType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FIELD_TYPE_UNSPECIFIED",
            Self::Username => "USERNAME",
            Self::Email => "EMAIL",
            Self::Password => "PASSWORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIELD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "USERNAME" => Some(Self::Username),
            "EMAIL" => Some(Self::Email),
            "PASSWORD" => Some(Self::Password),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValidationErrorCode {
    Unspecified = 0,
    Required = 1,
    TooShort = 2,
    TooLong = 3,
    InvalidCharacters = 4,
    InvalidFormat = 5,
    TooFewUppercaseLetters = 6,
    TooFewLowercaseLetters = 7,
    TooFewDigits = 8,
    TooFewSpecialCharacters = 9,
}
impl ValidationErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VALIDATION_ERROR_CODE_UNSPECIFIED",
            Self::Required => "REQUIRED",
            Self::TooShort => "TOO_SHORT",
            Self::TooLong => "TOO_LONG",
            Self::InvalidCharacters => "INVALID_CHARACTERS",
            Self::InvalidFormat => "INVALID_FORMAT",
            Self::TooFewUppercaseLetters => "TOO_FEW_UPPERCASE_LETTERS",
            Self::TooFewLowercaseLetters => "TOO_FEW_LOWERCASE_LETTERS",
            Self::TooFewDigits => "TOO_FEW_DIGITS",
            Self::TooFewSpecialCharacters => "TOO_FEW_SPECIAL_CHARACTERS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALIDATION_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "REQUIRED" => Some(Self::Required),
            "TOO_SHORT" => Some(Self::TooShort),
            "TOO_LONG" => Some(Self::TooLong),
            "INVALID_CHARACTERS" => Some(Self::InvalidCharacters),
            "INVALID_FORMAT" => Some(Self::InvalidFormat),
            "TOO_FEW_UPPERCASE_LETTERS" => Some(Self::TooFewUppercaseLetters),
            "TOO_FEW_LOWERCASE_LETTERS" => Some(Self::TooFewLowercaseLetters),
            "TOO_FEW_DIGITS" => Some(Self::TooFewDigits),
            "TOO_FEW_SPECIAL_CHARACTERS" => Some(Self::TooFewSpecialCharacters),
            _ => None,
        }
    }
}
/// Password strength levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PasswordStrength {
    Unspecified = 0,
    Weak = 1,
    Medium = 2,
    Strong = 3,
    Cia = 4,
}
impl PasswordStrength {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PASSWORD_STRENGTH_UNSPECIFIED",
            Self::Weak => "PASSWORD_STRENGTH_WEAK",
            Self::Medium => "PASSWORD_STRENGTH_MEDIUM",
            Self::Strong => "PASSWORD_STRENGTH_STRONG",
            Self::Cia => "PASSWORD_STRENGTH_CIA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PASSWORD_STRENGTH_UNSPECIFIED" => Some(Self::Unspecified),
            "PASSWORD_STRENGTH_WEAK" => Some(Self::Weak),
            "PASSWORD_STRENGTH_MEDIUM" => Some(Self::Medium),
            "PASSWORD_STRENGTH_STRONG" => Some(Self::Strong),
            "PASSWORD_STRENGTH_CIA" => Some(Self::Cia),
            _ => None,
        }
    }
}
