use axum::{
    extract::State,
    http::StatusCode,
    response::IntoResponse,
};
use axum_extra::protobuf::Protobuf;
use sqlx::types::time::OffsetDateTime;
use std::sync::Arc;
use tracing::{debug, error};

use crate::db::{DBHandle, UserLogin, generate_verification_token, hash_token};
use crate::generated::v1::{api_response, ApiResponse, EmptyData, FieldType, HealthData, LoginResponseData, ResponseCode, ValidationErrorData};
use crate::email::EmailSender;

/// Handler for user registration
pub async fn register_user(
    State(db): State<Arc<DBHandle>>,
    Protobuf(payload): Protobuf<crate::generated::v1::RegistrationRequest>,
) -> impl IntoResponse {
    debug!(
        "Received registration request - username: {}, email: {}",
        payload.username, payload.email
    );

    // Validate input
    if payload.username.is_empty() || payload.email.is_empty() || payload.password.is_empty() {
        debug!(
            "Registration validation failed for '{}': fields cannot be empty",
            payload.username
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorInvalidInput.into(),
            data: None,
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response));
    }

    // Validate username using shared Rust library
    let username_result = field_validator::validate_username(&payload.username, 3, 20, true);
    if !username_result.is_valid {
        debug!(
            "Username validation failed for '{}': {:?}",
            payload.username, username_result.errors
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorValidation.into(),
            data: Some(api_response::Data::ValidationError(ValidationErrorData {
                field: FieldType::Username.into(),
                errors: username_result.errors.iter().map(|e| serde_json::to_string(e).unwrap_or_default()).collect(),
            })),
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response));
    }

    // Validate email using shared Rust library
    let email_result = field_validator::validate_email(&payload.email);
    if !email_result.is_valid {
        debug!(
            "Email validation failed for '{}': {:?}",
            payload.email, email_result.errors
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorValidation.into(),
            data: Some(api_response::Data::ValidationError(ValidationErrorData {
                field: FieldType::Email.into(),
                errors: email_result.errors.iter().map(|e| serde_json::to_string(e).unwrap_or_default()).collect(),
            })),
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response));
    }

    // Validate password strength using shared Rust library
    let password_result = field_validator::validate_password(&payload.password);
    if !password_result.is_valid {
        debug!(
            "Password validation failed for '{}': {:?}",
            payload.username, password_result.errors
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorValidation.into(),
            data: Some(api_response::Data::ValidationError(ValidationErrorData {
                field: FieldType::Password.into(),
                errors: password_result.errors.iter().map(|e| serde_json::to_string(e).unwrap_or_default()).collect(),
            })),
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response));
    }

    // Check if username already exists
    match db.user_login_table.is_username_free(&payload.username).await {
        Ok(true) => {
            debug!("Username '{}' is available", payload.username);
        }
        Ok(false) => {
            debug!("Registration failed: username '{}' already taken", payload.username);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorUsernameTaken.into(),
                data: None,
            };
            return (StatusCode::CONFLICT, Protobuf(response));
        }
        Err(e) => {
            debug!(
                "Database error checking username '{}': {:?}",
                payload.username, e
            );
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorDatabase.into(),
                data: None,
            };
            return (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response));
        }
    }

    // Create user login entry
    // user_id will be auto-generated by the database
    let hashed_password = match crate::db::hash_password(&payload.password) {
        Ok(h) => h,
        Err(e) => {
            debug!("Failed to hash password for '{}': {:?}", payload.username, e);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInternal.into(),
                data: None,
            };
            return (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response));
        }
    };

    let user_login = UserLogin {
        user_id: 0, // Will be set by database AUTOINCREMENT
        username: payload.username.clone(),
        email: payload.email.clone(),
        password: Some(hashed_password),
        email_verified: false, // Initially not verified
        email_verified_at: None, // Will be set when verified
    };

    // Insert user into database
    match db.user_login_table.new_user(&user_login).await {
        Ok(user_id) => {
            debug!("User record created for '{}' with id {}", payload.username, user_id);

            // Generate verification token
            let token = generate_verification_token();
            let token_hash = match hash_token(&token) {
                Ok(hash) => hash,
                Err(e) => {
                    debug!("Failed to hash token for '{}': {:?}. Attempting cleanup...", payload.username, e);
                    match db.user_login_table.delete(&payload.username).await {
                        Ok(_) => debug!("Cleanup successful: deleted user '{}'", payload.username),
                        Err(cleanup_e) => error!("Cleanup failed for user '{}': {:?}", payload.username, cleanup_e),
                    }
                    let response = ApiResponse {
                        success: false,
                        code: ResponseCode::ErrorInternal.into(),
                        data: None,
                    };
                    return (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response));
                }
            };

            // Set token expiry (2 hours from now)
            let expires_at = OffsetDateTime::now_utc() + time::Duration::hours(2);

            // Store token in database
            match db.email_verification_tokens_table.insert(user_id, &token_hash, expires_at).await {
                Ok(_) => {
                    debug!("Verification token stored for user_id: {}", user_id);

                    // Get base URL for verification link
                    let base_url = if db.is_dev {
                        "http://localhost:4000"
                    } else {
                        "https://example.com"
                    };

                    let verification_link = format!(
                        "{}/verify-email?token={}",
                        base_url,
                        token
                    );

                    // Send real email via MailHog
                    let email_sender = EmailSender::new_mailhog();
                    if let Err(e) = email_sender.send_verification_email(&payload.email, &verification_link).await {
                        error!("Failed to send verification email to {}: {:?}. Attempting cleanup...", payload.email, e);
                        match db.user_login_table.delete(&payload.username).await {
                            Ok(_) => debug!("Cleanup successful: deleted user '{}'", payload.username),
                            Err(cleanup_e) => error!("Cleanup failed for user '{}': {:?}", payload.username, cleanup_e),
                        }
                        let response = ApiResponse {
                            success: false,
                            code: ResponseCode::ErrorInternal.into(),
                            data: None,
                        };
                        return (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response));
                    }

                    let response = ApiResponse {
                        success: true,
                        code: ResponseCode::SuccessRegistered.into(),
                        data: Some(api_response::Data::Empty(EmptyData {})),
                    };
                    (StatusCode::CREATED, Protobuf(response))
                }
                Err(e) => {
                    debug!("Failed to store verification token for user_id {}: {:?}. Attempting cleanup...", user_id, e);
                    match db.user_login_table.delete(&payload.username).await {
                        Ok(_) => debug!("Cleanup successful: deleted user '{}'", payload.username),
                        Err(cleanup_e) => error!("Cleanup failed for user '{}': {:?}", payload.username, cleanup_e),
                    }
                    let response = ApiResponse {
                        success: false,
                        code: ResponseCode::ErrorDatabase.into(),
                        data: None,
                    };
                    (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response))
                }
            }
        }
        Err(e) => {
            let (code, status) = if e.to_string().contains("username already taken") {
                (ResponseCode::ErrorUsernameTaken, StatusCode::CONFLICT)
            } else {
                (ResponseCode::ErrorInternal, StatusCode::BAD_REQUEST)
            };
            debug!("Failed to create user '{}': {:?}", payload.username, e);
            let response = ApiResponse {
                success: false,
                code: code.into(),
                data: None,
            };
            (status, Protobuf(response))
        }
    }
}

/// Health check endpoint
pub async fn health_check() -> impl IntoResponse {
    let response = ApiResponse {
        success: true,
        code: ResponseCode::SuccessOk.into(),
        data: Some(api_response::Data::HealthData(HealthData {
            status: "healthy".to_string(),
        })),
    };
    (StatusCode::OK, Protobuf(response))
}

/// Handler for user login
pub async fn login_user(
    State(db): State<Arc<DBHandle>>,
    Protobuf(payload): Protobuf<crate::generated::v1::LoginRequest>,
) -> impl IntoResponse {
    debug!(
        "Received login request - username: {}",
        payload.username
    );

    // Validate input
    if payload.username.is_empty() || payload.password.is_empty() {
        debug!(
            "Login validation failed for '{}': fields cannot be empty",
            payload.username
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorInvalidInput.into(),
            data: None,
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response)).into_response();
    }

    // Validate username format (without length validation for login)
    let username_result = field_validator::validate_username(&payload.username, 3, 20, false);
    if !username_result.is_valid {
        debug!(
            "Username validation failed for '{}': {:?}",
            payload.username, username_result.errors
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorValidation.into(),
            data: Some(api_response::Data::ValidationError(ValidationErrorData {
                field: FieldType::Username.into(),
                errors: username_result.errors.iter().map(|e| serde_json::to_string(e).unwrap_or_default()).collect(),
            })),
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response)).into_response();
    }

    // Check if user exists
    let user = match db.user_login_table.get_by_username(&payload.username).await {
        Ok(user) => user,
        Err(sqlx::Error::RowNotFound) => {
            debug!("Login failed: user '{}' not found", payload.username);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInvalidCredentials.into(),
                data: None,
            };
            return (StatusCode::UNAUTHORIZED, Protobuf(response)).into_response();
        }
        Err(e) => {
            debug!(
                "Database error checking user '{}': {:?}",
                payload.username, e
            );
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorDatabase.into(),
                data: None,
            };
            return (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response)).into_response();
        }
    };

    // Check if email is verified
    if !user.email_verified {
        debug!(
            "Login failed: user '{}' has not verified their email",
            payload.username
        );
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorEmailNotVerified.into(),
            data: None,
        };
        return (StatusCode::UNAUTHORIZED, Protobuf(response)).into_response();
    }

    // Verify password
    match db.user_login_table
        .is_password_correct(&payload.username, &payload.password)
        .await
    {
        Ok(true) => {
            debug!("Login successful for '{}'", payload.username);
            let response_data = LoginResponseData {
                username: user.username,
                email: user.email,
            };
            let response = ApiResponse {
                success: true,
                code: ResponseCode::SuccessLogin.into(),
                data: Some(api_response::Data::LoginResponse(response_data)),
            };
            (StatusCode::OK, Protobuf(response)).into_response()
        }
        Ok(false) => {
            debug!("Login failed: incorrect password for '{}'", payload.username);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInvalidCredentials.into(),
                data: None,
            };
            (StatusCode::UNAUTHORIZED, Protobuf(response)).into_response()
        }
        Err(e) => {
            debug!(
                "Password verification error for '{}': {:?}",
                payload.username, e
            );
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInternal.into(),
                data: None,
            };
            (StatusCode::UNAUTHORIZED, Protobuf(response)).into_response()
        }
    }
}

/// Handler for email verification
pub async fn verify_email(
    State(db): State<Arc<DBHandle>>,
    Protobuf(payload): Protobuf<crate::generated::v1::EmailVerificationRequest>,
) -> impl IntoResponse {
    debug!(
        "Received email verification request - token: {}",
        payload.token
    );

    if payload.token.is_empty() {
        debug!("Email verification failed: token is empty");
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorInvalidToken.into(),
            data: None,
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response));
    }

    // Hash the provided token
    let token_hash = match hash_token(&payload.token) {
        Ok(hash) => hash,
        Err(e) => {
            debug!("Failed to hash verification token: {:?}", e);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInvalidToken.into(),
                data: None,
            };
            return (StatusCode::BAD_REQUEST, Protobuf(response));
        }
    };

    // Look up the token in the database
    let token_record = match db.email_verification_tokens_table.get_by_token_hash(&token_hash).await {
        Ok(record) => record,
        Err(sqlx::Error::RowNotFound) => {
            debug!("Verification token not found in database");
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInvalidToken.into(),
                data: None,
            };
            return (StatusCode::BAD_REQUEST, Protobuf(response));
        }
        Err(e) => {
            debug!("Database error looking up token: {:?}", e);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorDatabase.into(),
                data: None,
            };
            return (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response));
        }
    };

    // Check if token is expired
    if OffsetDateTime::now_utc() > token_record.expires_at {
        debug!("Verification token has expired");
        let response = ApiResponse {
            success: false,
            code: ResponseCode::ErrorInvalidToken.into(),
            data: None,
        };
        return (StatusCode::BAD_REQUEST, Protobuf(response));
    }

    // Check if user is already verified
    let user = match db.user_login_table.get_by_user_id(token_record.user_id).await {
        Ok(user) => user,
        Err(e) => {
            debug!("Failed to get user for verification: {:?}", e);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorInternal.into(),
                data: None,
            };
            return (StatusCode::BAD_REQUEST, Protobuf(response));
        }
    };

    if user.email_verified {
        debug!("User already verified");
        let response = ApiResponse {
            success: true,
            code: ResponseCode::SuccessEmailAlreadyVerified.into(),
            data: Some(api_response::Data::Empty(EmptyData {})),
        };
        return (StatusCode::OK, Protobuf(response));
    }

    // Mark email as verified
    match db.user_login_table.mark_email_verified(token_record.user_id).await {
        Ok(_) => {
            debug!("Email verified successfully for user_id: {}", token_record.user_id);

            // Delete the token to ensure single-use
            match db.email_verification_tokens_table.delete_by_user_id(token_record.user_id).await {
                Ok(_) => debug!("Verification token deleted for user_id: {}", token_record.user_id),
                Err(e) => debug!("Failed to delete token for user_id {}: {:?}", token_record.user_id, e),
            }

            let response = ApiResponse {
                success: true,
                code: ResponseCode::SuccessEmailVerified.into(),
                data: Some(api_response::Data::Empty(EmptyData {})),
            };
            (StatusCode::OK, Protobuf(response))
        }
        Err(e) => {
            debug!("Failed to mark email as verified: {:?}", e);
            let response = ApiResponse {
                success: false,
                code: ResponseCode::ErrorDatabase.into(),
                data: None,
            };
            (StatusCode::INTERNAL_SERVER_ERROR, Protobuf(response))
        }
    }
}
