// This file is @generated by prost-build.
/// Generic API response wrapper
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(enumeration = "ResponseCode", tag = "2")]
    pub code: i32,
    /// For responses with data, use oneof to handle different data types
    #[prost(oneof = "api_response::Data", tags = "3, 4, 5, 6, 7")]
    pub data: ::core::option::Option<api_response::Data>,
}
/// Nested message and enum types in `ApiResponse`.
pub mod api_response {
    /// For responses with data, use oneof to handle different data types
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(message, tag = "3")]
        LoginResponse(super::LoginResponseData),
        #[prost(message, tag = "4")]
        HealthData(super::HealthData),
        #[prost(message, tag = "5")]
        Empty(super::EmptyData),
        #[prost(message, tag = "6")]
        ValidationError(super::ValidationErrorData),
        #[prost(message, tag = "7")]
        CounterData(super::CounterData),
    }
}
/// Error details for validation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationErrorData {
    #[prost(enumeration = "FieldType", tag = "1")]
    pub field: i32,
    /// JSON strings of field_validator::ValidationError
    #[prost(string, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Empty data for responses without payload
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmptyData {}
/// Health check response data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthData {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
}
/// Registration request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistrationRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
}
/// Login request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
/// Login response data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponseData {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
}
/// Email verification request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmailVerificationRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// Counter data
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CounterData {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// Set counter request
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCounterRequest {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// Password reset request (initial step)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResetRequest {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// Password reset completion request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordResetCompleteRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_password: ::prost::alloc::string::String,
}
/// API Response Codes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResponseCode {
    Unspecified = 0,
    /// Success codes
    SuccessOk = 1,
    SuccessRegistered = 2,
    SuccessRegisteredVerificationPending = 3,
    SuccessLogin = 4,
    SuccessEmailVerified = 5,
    SuccessEmailAlreadyVerified = 6,
    SuccessPasswordResetRequested = 7,
    SuccessPasswordReset = 8,
    /// Error codes
    ErrorInvalidInput = 100,
    ErrorUsernameTaken = 101,
    ErrorInvalidCredentials = 102,
    ErrorEmailNotVerified = 103,
    ErrorInvalidToken = 104,
    ErrorDatabase = 105,
    ErrorInternal = 106,
    ErrorValidation = 107,
}
impl ResponseCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESPONSE_CODE_UNSPECIFIED",
            Self::SuccessOk => "SUCCESS_OK",
            Self::SuccessRegistered => "SUCCESS_REGISTERED",
            Self::SuccessRegisteredVerificationPending => {
                "SUCCESS_REGISTERED_VERIFICATION_PENDING"
            }
            Self::SuccessLogin => "SUCCESS_LOGIN",
            Self::SuccessEmailVerified => "SUCCESS_EMAIL_VERIFIED",
            Self::SuccessEmailAlreadyVerified => "SUCCESS_EMAIL_ALREADY_VERIFIED",
            Self::SuccessPasswordResetRequested => "SUCCESS_PASSWORD_RESET_REQUESTED",
            Self::SuccessPasswordReset => "SUCCESS_PASSWORD_RESET",
            Self::ErrorInvalidInput => "ERROR_INVALID_INPUT",
            Self::ErrorUsernameTaken => "ERROR_USERNAME_TAKEN",
            Self::ErrorInvalidCredentials => "ERROR_INVALID_CREDENTIALS",
            Self::ErrorEmailNotVerified => "ERROR_EMAIL_NOT_VERIFIED",
            Self::ErrorInvalidToken => "ERROR_INVALID_TOKEN",
            Self::ErrorDatabase => "ERROR_DATABASE",
            Self::ErrorInternal => "ERROR_INTERNAL",
            Self::ErrorValidation => "ERROR_VALIDATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESPONSE_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS_OK" => Some(Self::SuccessOk),
            "SUCCESS_REGISTERED" => Some(Self::SuccessRegistered),
            "SUCCESS_REGISTERED_VERIFICATION_PENDING" => {
                Some(Self::SuccessRegisteredVerificationPending)
            }
            "SUCCESS_LOGIN" => Some(Self::SuccessLogin),
            "SUCCESS_EMAIL_VERIFIED" => Some(Self::SuccessEmailVerified),
            "SUCCESS_EMAIL_ALREADY_VERIFIED" => Some(Self::SuccessEmailAlreadyVerified),
            "SUCCESS_PASSWORD_RESET_REQUESTED" => {
                Some(Self::SuccessPasswordResetRequested)
            }
            "SUCCESS_PASSWORD_RESET" => Some(Self::SuccessPasswordReset),
            "ERROR_INVALID_INPUT" => Some(Self::ErrorInvalidInput),
            "ERROR_USERNAME_TAKEN" => Some(Self::ErrorUsernameTaken),
            "ERROR_INVALID_CREDENTIALS" => Some(Self::ErrorInvalidCredentials),
            "ERROR_EMAIL_NOT_VERIFIED" => Some(Self::ErrorEmailNotVerified),
            "ERROR_INVALID_TOKEN" => Some(Self::ErrorInvalidToken),
            "ERROR_DATABASE" => Some(Self::ErrorDatabase),
            "ERROR_INTERNAL" => Some(Self::ErrorInternal),
            "ERROR_VALIDATION" => Some(Self::ErrorValidation),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldType {
    Unspecified = 0,
    Username = 1,
    Email = 2,
    Password = 3,
}
impl FieldType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FIELD_TYPE_UNSPECIFIED",
            Self::Username => "FIELD_TYPE_USERNAME",
            Self::Email => "FIELD_TYPE_EMAIL",
            Self::Password => "FIELD_TYPE_PASSWORD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIELD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FIELD_TYPE_USERNAME" => Some(Self::Username),
            "FIELD_TYPE_EMAIL" => Some(Self::Email),
            "FIELD_TYPE_PASSWORD" => Some(Self::Password),
            _ => None,
        }
    }
}
/// Password strength levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PasswordStrength {
    Unspecified = 0,
    Weak = 1,
    Medium = 2,
    Strong = 3,
}
impl PasswordStrength {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PASSWORD_STRENGTH_UNSPECIFIED",
            Self::Weak => "PASSWORD_STRENGTH_WEAK",
            Self::Medium => "PASSWORD_STRENGTH_MEDIUM",
            Self::Strong => "PASSWORD_STRENGTH_STRONG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PASSWORD_STRENGTH_UNSPECIFIED" => Some(Self::Unspecified),
            "PASSWORD_STRENGTH_WEAK" => Some(Self::Weak),
            "PASSWORD_STRENGTH_MEDIUM" => Some(Self::Medium),
            "PASSWORD_STRENGTH_STRONG" => Some(Self::Strong),
            _ => None,
        }
    }
}
