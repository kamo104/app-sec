% Component Description - Purpose, responsibilities, data collected, security assumptions
\section{Component Description}

\subsection{Purpose}

The registration module provides a secure mechanism for creating user accounts and verifying ownership of email addresses before granting access to the application.

Its main goals are:

\begin{enumerate}[leftmargin=*,nosep]
  \item Ensure only valid, well-formed data is accepted through dual validation (frontend and backend).
  \item Prevent user enumeration and information leakage through generic error responses.
  \item Protect passwords using Argon2 hashing with random salts.
  \item Store verification tokens as SHA256 hashes, never in plaintext.
  \item Enforce email verification before the account can be used.
  \item Automatically clean up expired tokens and unverified accounts.
\end{enumerate}

\subsection{Responsibilities}

\begin{itemize}[leftmargin=*,nosep]
  \item Accept registration requests with username, email, and password.
  \item Validate input on both frontend (via WASM) and backend (native Rust).
  \item Hash passwords using Argon2 with random salts before storage.
  \item Generate 32-byte cryptographically secure verification tokens.
  \item Store only SHA256 hashes of tokens in the database.
  \item Send verification emails via SMTP (MailHog in development).
  \item Verify email tokens and mark users as verified.
  \item Clean up expired tokens and unverified users automatically.
  \item Provide translated error messages via the translator crate.
\end{itemize}

\subsection{Data Collected}

The registration module stores the minimal data required for account creation and email verification.

\subsubsection*{User Login Table (\texttt{user\_login})}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{user\_id}: INTEGER, primary key, auto-increment
  \item \texttt{username}: TEXT, unique, not null
  \item \texttt{email}: TEXT, unique, not null
  \item \texttt{password}: TEXT (Argon2 hash, nullable for password reset state)
  \item \texttt{email\_verified}: INTEGER (boolean), default 0
  \item \texttt{email\_verified\_at}: INTEGER (timestamp), nullable
  \item \texttt{password\_reset}: INTEGER (boolean), default 0
\end{itemize}

\subsubsection*{User Data Table (\texttt{user\_data})}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{user\_id}: INTEGER, primary key, foreign key to \texttt{user\_login} with CASCADE
  \item \texttt{counter}: INTEGER, default 0 (application-specific data)
\end{itemize}

\subsubsection*{Email Verification Tokens Table (\texttt{email\_verification\_tokens})}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{user\_id}: INTEGER, primary key, foreign key to \texttt{user\_login} with CASCADE
  \item \texttt{token\_hash}: TEXT (SHA256 hash of the token)
  \item \texttt{expires\_at}: INTEGER (Unix timestamp)
  \item \texttt{created\_at}: INTEGER (Unix timestamp)
\end{itemize}

\subsection{Security Assumptions}

\begin{itemize}[leftmargin=*,nosep]
  \item All traffic is served over HTTPS in production.
  \item Database is encrypted using SQLCipher with a 32-byte key stored in system keyring or environment variable.
  \item Email delivery is handled via SMTP (MailHog for development, production SMTP for deployment).
  \item Verification tokens are sent only to the user's email address.
  \item Passwords are never logged, stored in plaintext, or returned to the client.
  \item Frontend validation is for user experience; backend validation is authoritative.
  \item Expired tokens and unverified users are cleaned up automatically every hour.
\end{itemize}
