% Building and Running
\section{Building and Running}

\subsection{Build Process}

The project uses \texttt{build.sh} to orchestrate the entire build process:

\begin{verbatim}
# Full build (WASM, backend, OpenAPI client, frontend)
./build.sh

# Development mode with hot reload
./dev.sh
\end{verbatim}

The build script handles:
\begin{itemize}[leftmargin=*,nosep]
  \item WASM module compilation (\texttt{field-validator}, \texttt{translator})
  \item Backend build with OpenAPI generation
  \item TypeScript client generation from OpenAPI spec
  \item Frontend build
\end{itemize}

\subsection{Development Mode}

In development mode:
\begin{itemize}[leftmargin=*,nosep]
  \item Swagger UI available at \texttt{http://localhost:4000/api/docs}
  \item Emails sent to MailHog at \texttt{http://localhost:8025}
  \item Database is unencrypted (\texttt{data\_dev.db})
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{10-usage/swagger-ui.png}
    \caption{Swagger UI showing the API documentation interface available at \texttt{/api/docs} in development mode. Provides interactive testing of all API endpoints.}
    \label{fig:swagger-ui}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{10-usage/mailhog.png}
    \caption{MailHog email testing interface showing captured verification emails. Allows developers to inspect email content and click verification links without sending real emails.}
    \label{fig:mailhog}
\end{figure}

\subsection{Production Mode}

In production mode:
\begin{itemize}[leftmargin=*,nosep]
  \item Database encrypted with SQLCipher (\texttt{data.db})
  \item OpenAPI endpoints disabled
  \item HTTPS required for all traffic
\end{itemize}

\begin{newcontent}
\subsection{Configuration}

The application is configured via \texttt{config.toml} in the working directory. Key sections:

\begin{verbatim}
[server]
bind_addr = "0.0.0.0"      # Listen on all interfaces
port = 4000
dev_mode = false           # Production mode
max_body_size = 10485760   # 10MB

[database]
prod_path = "/app/data/data.db"
db_key_env_var_name = "APPSEC_DB_KEY"

[tls]
enabled = true
cert_path = "/app/certs/cert.pem"
key_path = "/app/certs/key.pem"

[security]
hsts_enabled = true
hsts_max_age_seconds = 31536000  # 1 year
hsts_include_subdomains = true
cors_allowed_origins = "https://example.com"

[mail]
smtp_host = "mailhog"
smtp_port = 1025
from_email = "noreply@example.com"
\end{verbatim}

\subsection{Docker Deployment}

The application includes Docker support for containerized deployment.

\subsubsection{Prerequisites}

\begin{itemize}[leftmargin=*,nosep]
  \item Docker and Docker Compose installed
  \item TLS certificates (self-signed for testing or CA-signed for production)
\end{itemize}

\subsubsection{Generate TLS Certificates}

For local testing, generate self-signed certificates:

\begin{verbatim}
# Using the provided script
./generate-certs.sh

# Or manually with OpenSSL
openssl req -x509 -newkey rsa:4096 \
    -keyout certs/key.pem \
    -out certs/cert.pem \
    -days 365 -nodes \
    -subj "/CN=localhost/O=AppSec/C=US" \
    -addext "subjectAltName=DNS:localhost,IP:127.0.0.1"
\end{verbatim}

\subsubsection{Set Environment Variables}

Create a \texttt{.env} file with the database encryption key:

\begin{verbatim}
# Generate a 64-character hex key (32 bytes)
echo "APPSEC_DB_KEY=$(openssl rand -hex 32)" > .env
\end{verbatim}

\subsubsection{Docker Compose Configuration}

The \texttt{docker-compose.yml} defines the application stack:

\begin{verbatim}
services:
  app:
    build: .
    ports:
      - "4000:4000"
    environment:
      - APPSEC_DB_KEY=${APPSEC_DB_KEY}
    volumes:
      - app-data:/app/data
      - ./certs:/app/certs:ro
    depends_on:
      - mailhog

  mailhog:
    image: mailhog/mailhog:latest
    ports:
      - "8025:8025"  # Web UI
      - "1025:1025"  # SMTP

volumes:
  app-data:
\end{verbatim}

\subsubsection{Build and Run}

\begin{verbatim}
# Build the Docker image
docker-compose build

# Start the containers
docker-compose up -d

# View logs
docker-compose logs -f app

# Stop the containers
docker-compose down

# Stop and remove volumes (clears database)
docker-compose down -v
\end{verbatim}

\subsubsection{Verify Deployment}

Test the deployment with curl:

\begin{verbatim}
# Test HTTPS (use -k to accept self-signed cert)
curl -k https://localhost:4000/api/health

# Check HSTS header
curl -k -I https://localhost:4000/api/health

# Expected header:
# strict-transport-security: max-age=31536000; includeSubDomains
\end{verbatim}

\subsubsection{Accessing the Application}

\begin{itemize}[leftmargin=*,nosep]
  \item Application: \texttt{https://localhost:4000}
  \item MailHog UI: \texttt{http://localhost:8025} (for viewing test emails)
\end{itemize}

\subsection{Production Deployment Checklist}

Before deploying to production:

\begin{itemize}[leftmargin=*,nosep]
  \item Use CA-signed TLS certificates (e.g., Let's Encrypt).
  \item Set a strong, randomly generated \texttt{APPSEC\_DB\_KEY}.
  \item Configure \texttt{cors\_allowed\_origins} with your domain.
  \item Update \texttt{base\_url\_prod} in config to your domain.
  \item Configure a real SMTP server for email delivery.
  \item Enable \texttt{hsts\_preload} only if submitting to the HSTS preload list.
  \item Set up persistent storage for \texttt{/app/data} volume.
  \item Configure reverse proxy (nginx, Caddy) if needed.
  \item Set up monitoring and logging.
\end{itemize}
\end{newcontent}
