% Implementation Details - Code examples and implementation specifics
\section{Implementation Details}

This section provides implementation details including code examples, screenshots, and the client generation process.

\subsection{User Interface - Registration}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/registration-form.png}
    \caption{Registration form with real-time field validation. Shows username, email, and password fields with immediate feedback on input validity using WASM-based validation.}
    \label{fig:registration-form}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.5\textwidth]{09-implementation/password-strength.png}
    \caption{Password strength indicator showing the 0--7 score system. Visual feedback updates in real-time as the user types, displaying strength level (weak/medium/strong/cia) and specific requirements not yet met.}
    \label{fig:password-strength}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.5\textwidth]{09-implementation/registration-success.png}
    \caption{Successful registration confirmation message. Informs the user that a verification email has been sent and provides next steps.}
    \label{fig:registration-success}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/email-verification.png}
    \caption{Email verification page showing successful account activation. Displayed after the user clicks the verification link from their email.}
    \label{fig:email-verification}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[height=0.7\textwidth]{09-implementation/validation-errors.png}
    \caption{Form displaying validation errors with translated messages. Shows field-specific error messages generated by the WASM translator module.}
    \label{fig:validation-errors}
\end{figure}

\begin{newcontent}
\subsection{User Interface - Login}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/login-form.png}
    \caption{Login form with username and password fields. Includes ``Remember me'' checkbox and link to forgot password page.}
    \label{fig:login-form}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/login-success.png}
    \caption{Successful login showing redirect to home page with user session information displayed.}
    \label{fig:login-success}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/login-error.png}
    \caption{Login error displaying translated error message for invalid credentials or unverified email.}
    \label{fig:login-error}
\end{figure}

\subsection{User Interface - Password Reset}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/forgot-password.png}
    \caption{Forgot password page where users enter their email address to request a password reset link.}
    \label{fig:forgot-password}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/reset-password.png}
    \caption{Password reset form where users enter their new password after clicking the reset link from email.}
    \label{fig:reset-password}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{09-implementation/reset-success.png}
    \caption{Successful password reset confirmation with link to login page.}
    \label{fig:reset-success}
\end{figure}
\end{newcontent}

\subsection{Frontend Client Generation}

The build script (\texttt{build.sh}) fetches the OpenAPI spec from the running backend:

\begin{verbatim}
curl -s http://localhost:4000/api/openapi.json \
  > frontend/src/generated/openapi.json
\end{verbatim}

TypeScript client is generated using \texttt{@hey-api/openapi-ts}:

\begin{verbatim}
npx @hey-api/openapi-ts \
  --input src/generated/openapi.json \
  --output src/generated/api-client \
  --client @hey-api/client-fetch
\end{verbatim}

Generated files in \texttt{frontend/src/generated/api-client/}:
\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{types.gen.ts}: All TypeScript interfaces (\texttt{RegistrationRequest}, \texttt{LoginResponse}, etc.)
  \item \texttt{sdk.gen.ts}: Typed API functions (\texttt{registerUser()}, \texttt{verifyEmail()}, \texttt{login()}, etc.)
  \item \texttt{index.ts}: Re-exports for convenient imports
\end{itemize}

Client configured in \texttt{frontend/src/api/client.ts} with base URL and credentials.

\subsection{Registration Flow Implementation}

Frontend registration call (\texttt{frontend/src/pages/register.vue}):

\begin{lstlisting}[language=Java]
import { registerUser } from '@/generated/api-client';

const { data, error, response } = await registerUser({
  body: {
    username: formData.username,
    email: formData.email,
    password: formData.password,
  }
});

if (response.ok) {
  // Show translated success message
  statusMessage.value = translate('SUCCESS_REGISTERED', undefined);
} else if (error) {
  // Handle specific error codes
  if (error.error === 'USERNAME_TAKEN') {
    statusMessage.value = translate_error_code('USERNAME_TAKEN', undefined);
  } else if (error.error === 'VALIDATION') {
    // Display field-specific errors
    error.validation?.fieldErrors.forEach(fieldError => {
      fieldError.errors.forEach(code => {
        const msg = translate_field_validation_error(
          fieldError.field, code, undefined
        );
      });
    });
  }
}
\end{lstlisting}

\subsection{Email Verification Implementation}

Frontend verification (\texttt{frontend/src/pages/verify-email.vue}):

\begin{lstlisting}[language=Java]
import { verifyEmail } from '@/generated/api-client';

// Extract token from URL query parameter
const route = useRoute();
const token = route.query.token as string;

if (!token) {
  // Show warning: no token provided
  return;
}

const { data, error, response } = await verifyEmail({
  body: { token }
});

if (response.ok) {
  // Show success, navigate to login
  statusMessage.value = translate('SUCCESS_EMAIL_VERIFIED', undefined);
} else {
  // Show error (TOKEN_EXPIRED or INTERNAL)
  statusMessage.value = translate_error_code(error.error, undefined);
}
\end{lstlisting}

\subsection{Password Strength Validation}

Frontend password field uses detailed validation (\texttt{frontend/src/components/auth/PasswordField.vue}):

\begin{lstlisting}[language=Java]
import { validate_password_detailed } from '@/wasm/field-validator';

const result = JSON.parse(validate_password_detailed(password));

// result.score: 0-7 (based on length and character types)
// result.strength: "weak" | "medium" | "strong" | "cia"
// result.errors: ["TOO_SHORT", "TOO_FEW_UPPERCASE_LETTERS", ...]

// Score calculation:
// +1 for length >= 8
// +1 for length >= 12
// +1 for length >= 16
// +1 for uppercase letter
// +1 for lowercase letter
// +1 for digit
// +1 for special character
\end{lstlisting}

\begin{newcontent}
\subsection{Session Management Implementation}

Frontend session handling (\texttt{frontend/src/stores/auth.ts}):

\begin{lstlisting}[language=Java]
// On login success
authStore.setUser(data)  // Stores user in state and localStorage

// Session refresh scheduling
const sessionLifetime = sessionExpiresAt - sessionCreatedAt
const refreshAt = sessionCreatedAt + (sessionLifetime / 2)
// Timer calls POST /api/auth/refresh at 50% of session lifetime

// On logout
authStore.clearUser()  // Clears state and localStorage
\end{lstlisting}
\end{newcontent}

\begin{newcontent}
\subsection{Backend Implementation Examples}

\subsubsection{Password Strength Calculation (Rust)}

The \texttt{validate\_password\_detailed} function in \texttt{field-validator/src/lib.rs} calculates password strength:

\begin{lstlisting}[language=C,basicstyle=\ttfamily\footnotesize]
pub fn validate_password_detailed(password: &str) -> String {
    let validation_errors = validate_password(password);

    // Calculate score based on various factors
    let mut score = 0u32;
    let len = password.len();

    let mut has_upper = false;
    let mut has_lower = false;
    let mut has_digit = false;
    let mut has_special = false;

    for c in password.chars() {
        has_upper |= c.is_uppercase();
        has_lower |= c.is_lowercase();
        has_digit |= c.is_numeric();
        has_special |= !c.is_alphanumeric();
    }

    score += (len >= 8) as u32;   // +1 for length >= 8
    score += (len >= 12) as u32;  // +1 for length >= 12
    score += (len >= 16) as u32;  // +1 for length >= 16
    score += has_upper as u32;    // +1 for uppercase
    score += has_lower as u32;    // +1 for lowercase
    score += has_digit as u32;    // +1 for digit
    score += has_special as u32;  // +1 for special char

    let strength = match score {
        ..=PASSWORD_SCORE_WEAK_MAX => PasswordStrength::Weak,
        ..=PASSWORD_SCORE_MEDIUM_MAX => PasswordStrength::Medium,
        ..=PASSWORD_SCORE_STRONG_MAX => PasswordStrength::Strong,
        _ => PasswordStrength::Cia,
    };
    // Return JSON with errors, strength, and score
    serde_json::to_string(&ValidationDetailedPasswordData::new(
        validation_errors, strength, score
    )).unwrap_or_default()
}
\end{lstlisting}

\subsubsection{Login Handler with Session Creation (Rust)}

Key parts of the login handler in \texttt{backend/src/api/login.rs} showing session token generation and cookie setting:

\begin{lstlisting}[language=C,basicstyle=\ttfamily\footnotesize]
// After successful password verification...
let session_token = generate_session_token(config.session.token_bytes);
let session_hash = hash_token(&session_token)?;  // SHA256 hash for storage

let now = OffsetDateTime::now_utc();
let expiry = now + time::Duration::days(config.session.duration_days);
let session = UserSession {
    user_id: user.user_id,
    session_id: generate_session_id(),
    session_hash,  // Only hash stored in database
    session_expiry: expiry,
    session_created_at: now,
};

db.user_sessions_table.insert(&session).await?;

// Set HTTP-only cookie with the actual token (not hash)
let cookie = create_session_cookie(session_token, Some(expiry), db.is_dev);
cookies.add(cookie);

// Return session metadata (timestamps for client-side refresh scheduling)
LoginResponse {
    username: user.username,
    email: user.email,
    role: user.role,
    session_expires_at: expiry.unix_timestamp(),
    session_created_at: now.unix_timestamp(),
}
\end{lstlisting}

\subsubsection{Session Database Operations (Rust)}

The \texttt{UserSession} struct and key operations from \texttt{backend/src/db/user\_sessions.rs}:

\begin{lstlisting}[language=C,basicstyle=\ttfamily\footnotesize]
#[derive(FromRow, Clone, Debug)]
pub struct UserSession {
    pub user_id: i64,
    pub session_id: String,
    pub session_hash: String,        // SHA256 hash of session token
    pub session_expiry: OffsetDateTime,
    pub session_created_at: OffsetDateTime,
}

impl UserSessionsTable {
    pub async fn insert(&self, row: &UserSession) -> Result<()> {
        sqlx::query("INSERT INTO user_sessions (...) VALUES ($1, $2, $3, $4, $5)")
            .bind(row.user_id)
            .bind(&row.session_id)
            .bind(&row.session_hash)
            .bind(row.session_expiry)
            .bind(row.session_created_at)
            .execute(&self.conn_pool).await?;
        Ok(())
    }

    pub async fn get_by_hash(&self, session_hash: &str)
        -> Result<UserSession, sqlx::Error>
    {
        sqlx::query_as::<_, UserSession>(
            "SELECT * FROM user_sessions WHERE session_hash = $1"
        ).bind(session_hash).fetch_one(&self.conn_pool).await
    }

    pub async fn cleanup_expired_sessions(&self) -> Result<()> {
        sqlx::query("DELETE FROM user_sessions WHERE session_expiry < $1")
            .bind(OffsetDateTime::now_utc())
            .execute(&self.conn_pool).await?;
        Ok(())
    }
}
\end{lstlisting}
\end{newcontent}

\subsection{Implementation Files}

\subsubsection{Backend Files}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{backend/src/main.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Application entry point.
    \item Configures Axum router with API routes using \texttt{utoipa-axum}.
    \item Builds OpenAPI spec at runtime with \texttt{OpenApiRouter::with\_openapi()}.
    \item Mounts Swagger UI at \texttt{/api/docs} in dev mode.
    \item Initializes database connection and starts cleanup task.
  \end{itemize}
  \item \texttt{backend/src/api/register.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{POST /api/register} handler with \texttt{\#[utoipa::path()]} annotation.
    \item Validates input, checks uniqueness, creates user.
    \item Generates verification token and sends email.
  \end{itemize}
  \item \texttt{backend/src/api/verify\_email.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{POST /api/verify-email} handler with \texttt{\#[utoipa::path()]} annotation.
    \item Verifies token and marks user as verified.
  \end{itemize}
\begin{newcontent}
  \item \texttt{backend/src/api/login.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{POST /api/login} handler.
    \item Validates credentials, checks email verification.
    \item Creates session and sets HTTP-only cookie.
  \end{itemize}
  \item \texttt{backend/src/api/logout.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{POST /api/logout} handler.
    \item Deletes session from database.
    \item Clears session cookie.
  \end{itemize}
  \item \texttt{backend/src/api/auth.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{GET /api/auth/check} -- Validates session and returns user info.
    \item \texttt{POST /api/auth/refresh} -- Extends session lifetime.
  \end{itemize}
  \item \texttt{backend/src/api/auth\_extractor.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Axum extractor for session validation.
    \item Reads session token from cookie.
    \item Validates against database.
  \end{itemize}
  \item \texttt{backend/src/api/password\_reset.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{POST /api/request-password-reset} -- Generates reset token.
    \item \texttt{POST /api/complete-password-reset} -- Validates token and updates password.
  \end{itemize}
  \item \texttt{backend/src/db/user\_sessions.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Session table operations: create, lookup, delete, refresh.
  \end{itemize}
  \item \texttt{backend/src/db/password\_reset\_tokens.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Reset token table operations: create (UPSERT), lookup, delete.
  \end{itemize}
\end{newcontent}
  \item \texttt{backend/src/api/utils.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Configuration constants from \texttt{build.rs}.
    \item Token duration settings, base URLs.
    \item Cookie creation helper functions.
  \end{itemize}
  \item \texttt{backend/src/db/mod.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{DBHandle} struct with connection pool.
    \item Password hashing with Argon2.
    \item Cleanup task for expired tokens and sessions.
  \end{itemize}
  \item \texttt{backend/src/db/user\_login.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item User table operations: create, lookup, verify.
  \end{itemize}
  \item \texttt{backend/src/db/user\_data.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item User data table operations.
  \end{itemize}
  \item \texttt{backend/src/db/email\_verification\_tokens.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Token table operations: create, lookup, delete.
  \end{itemize}
  \item \texttt{backend/src/email.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item SMTP email sending via \texttt{lettre}.
    \item Verification and password reset email templates.
  \end{itemize}
\end{itemize}

\subsubsection{Frontend Files}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{frontend/src/pages/register.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Registration page with form.
    \item Uses generated \texttt{registerUser()} from API client.
    \item Real-time validation and error display.
  \end{itemize}
  \item \texttt{frontend/src/pages/verify-email.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Email verification page.
    \item Uses generated \texttt{verifyEmail()} from API client.
    \item Extracts token from URL and calls API.
  \end{itemize}
\begin{newcontent}
  \item \texttt{frontend/src/pages/login.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Login page with username/password form.
    \item Handles session storage on success.
    \item Displays login errors with translation.
  \end{itemize}
  \item \texttt{frontend/src/pages/forgot-password.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Password reset request page.
    \item Email input with validation.
    \item Always shows success message (security).
  \end{itemize}
  \item \texttt{frontend/src/pages/reset-password.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Password reset completion page.
    \item Extracts token from URL.
    \item New password input with strength validation.
  \end{itemize}
  \item \texttt{frontend/src/stores/auth.ts}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Pinia store for authentication state.
    \item Manages user session data.
    \item Handles session refresh scheduling.
  \end{itemize}
\end{newcontent}
  \item \texttt{frontend/src/components/auth/UsernameField.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Username input with WASM validation.
  \end{itemize}
  \item \texttt{frontend/src/components/auth/EmailField.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Email input with WASM validation.
  \end{itemize}
  \item \texttt{frontend/src/components/auth/PasswordField.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Password input with strength indicator (0--7 score).
    \item WASM validation with detailed errors.
  \end{itemize}
  \item \texttt{frontend/src/components/auth/ConfirmPasswordField.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Password confirmation with match validation.
  \end{itemize}
  \item \texttt{frontend/src/components/auth/AuthFormLayout.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Common layout for auth forms.
  \end{itemize}
  \item \texttt{frontend/src/components/auth/StatusMessage.vue}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Success/error message display.
  \end{itemize}
  \item \texttt{frontend/src/api/client.ts}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item API client configuration (base URL, credentials).
    \item Re-exports generated API client for convenient imports.
  \end{itemize}
\end{itemize}

\subsubsection{Generated Files (Auto-Generated)}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{frontend/src/generated/openapi.json}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item OpenAPI 3.1 specification fetched from backend.
    \item Source of truth for client generation.
  \end{itemize}
  \item \texttt{frontend/src/generated/api-client/types.gen.ts}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Auto-generated TypeScript interfaces from OpenAPI spec.
    \item Includes \texttt{RegistrationRequest}, \texttt{LoginResponse}, etc.
  \end{itemize}
  \item \texttt{frontend/src/generated/api-client/sdk.gen.ts}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Auto-generated typed API functions.
    \item Includes \texttt{registerUser()}, \texttt{verifyEmail()}, \texttt{login()}, \texttt{logout()}, etc.
  \end{itemize}
  \item \texttt{frontend/src/generated/api-client/index.ts}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item Re-exports all generated types and functions.
  \end{itemize}
\end{itemize}

\subsubsection{Shared Crates}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{api-types/src/}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{requests.rs}: Request types with \texttt{ToSchema} derivation.
    \item \texttt{responses.rs}: Response and error types with \texttt{ToSchema} derivation.
    \item \texttt{validation.rs}: Validation data structures.
    \item \texttt{enums.rs}: \texttt{FieldType}, \texttt{ValidationErrorCode}, \texttt{PasswordStrength}.
    \item \texttt{Cargo.toml}: \texttt{openapi} feature flag for conditional \texttt{utoipa} support.
  \end{itemize}
  \item \texttt{field-validator/src/lib.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{validate\_username()}, \texttt{validate\_email()}, \texttt{validate\_password()}
    \item \texttt{validate\_field()} -- WASM-exported wrapper
    \item \texttt{validate\_password\_detailed()} -- Returns strength score
  \end{itemize}
  \item \texttt{translator/src/lib.rs}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{translate()}, \texttt{translate\_error\_code()}
    \item \texttt{translate\_field\_validation\_error()}
  \end{itemize}
  \item \texttt{translator/locales/en.yml}
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item English translations for all error codes and messages.
  \end{itemize}
\end{itemize}

\subsubsection{Build and Configuration Files}

\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{build.sh} -- Main build script (WASM, backend, OpenAPI, frontend)
  \item \texttt{dev.sh} -- Development mode launcher
  \item \texttt{Dockerfile} -- Container build configuration
  \item \texttt{backend/.env} -- Environment variables (token durations, base URLs)
  \item \texttt{backend/build.rs} -- Compile-time constant generation
  \item \texttt{Cargo.toml} -- Workspace with utoipa dependencies
  \item \texttt{frontend/package.json} -- NPM scripts including \texttt{generate:api}
\end{itemize}
