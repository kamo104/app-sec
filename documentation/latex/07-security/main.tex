% Security Mechanisms
\section{Security Mechanisms}

This section describes the security measures implemented in the authentication module.

\subsection{Password Security}

\begin{itemize}[leftmargin=*,nosep]
  \item Argon2 algorithm (memory-hard, GPU-resistant).
  \item Random salt generated using \texttt{SaltString::generate(\&mut OsRng)}.
  \item Password hash stored in PHC string format (includes algorithm, parameters, salt).
  \item Passwords are never logged, stored in plaintext, or returned to clients.
  \item Password complexity requirements: 8--64 characters, uppercase, lowercase, digit, special character.
  \item Password strength scoring (0--7) provides user feedback.
\end{itemize}

\subsection{Token Security}

\subsubsection{Email Verification Tokens}
\begin{itemize}[leftmargin=*,nosep]
  \item 32 bytes of cryptographically secure random data (\texttt{OsRng}).
  \item Hex-encoded for transmission (64 characters).
  \item Only SHA256 hashes stored in database.
  \item Plaintext tokens sent only via email, never logged.
  \item Configurable expiry (\texttt{EMAIL\_VERIFICATION\_TOKEN\_DURATION\_HOURS}).
  \item One token per user (primary key constraint).
  \item Deleted after successful verification.
\end{itemize}

\subsubsection{Session Tokens}
\begin{itemize}[leftmargin=*,nosep]
  \item 32 bytes of cryptographically secure random data.
  \item Stored in HTTP-only cookies (inaccessible to JavaScript).
  \item Only SHA256 hashes stored in database.
  \item Cookies set with \texttt{Secure} flag in production (HTTPS only).
  \item \texttt{SameSite=Strict} prevents CSRF attacks by blocking cross-site cookie transmission.
  \item Configurable duration (\texttt{SESSION\_DURATION\_DAYS}, default 7).
  \item Users can have multiple active sessions (multi-device).
  \item Session refresh extends expiry without generating new token.
\end{itemize}

\subsubsection{Password Reset Tokens}
\begin{itemize}[leftmargin=*,nosep]
  \item 32 bytes of cryptographically secure random data.
  \item Only SHA256 hashes stored in database.
  \item Configurable expiry (\texttt{PASSWORD\_RESET\_TOKEN\_DURATION\_HOURS}).
  \item One token per user (new request overwrites existing via UPSERT).
  \item Deleted after successful password reset.
  \item Password reset flag tracks active reset process.
\end{itemize}

\subsection{Session Management Security}

\begin{itemize}[leftmargin=*,nosep]
  \item Server-side session storage (no sensitive data in cookie).
  \item Session lookup by token hash is O(1) via primary key.
  \item Cookie attributes:
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{HttpOnly}: Prevents XSS attacks from accessing token.
    \item \texttt{Secure}: Cookie only sent over HTTPS (production).
    \item \texttt{SameSite=Strict}: Prevents CSRF by blocking cross-site requests.
    \item \texttt{Path=/}: Cookie sent with all requests to origin.
  \end{itemize}
  \item Logout invalidates session server-side and clears cookie.
  \item Expired sessions cannot be used (server validates expiry).
\end{itemize}

\begin{newcontent}
\subsection{Transport Layer Security (TLS)}

The application supports HTTPS with TLS 1.3 for secure communication:

\begin{itemize}[leftmargin=*,nosep]
  \item TLS termination handled by \texttt{axum-server} with \texttt{rustls} backend.
  \item Uses the \texttt{ring} cryptographic provider for TLS operations.
  \item Certificate and key paths configurable via \texttt{config.toml}:
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{tls.enabled}: Toggle TLS on/off.
    \item \texttt{tls.cert\_path}: Path to PEM certificate file.
    \item \texttt{tls.key\_path}: Path to PEM private key file.
  \end{itemize}
  \item Self-signed certificates can be generated for development using the included \texttt{generate-certs.sh} script.
  \item Production deployments should use certificates from a trusted CA (e.g., Let's Encrypt).
\end{itemize}

\subsection{HTTP Strict Transport Security (HSTS)}

HSTS ensures browsers always use HTTPS for the application:

\begin{itemize}[leftmargin=*,nosep]
  \item Implemented as Axum middleware that adds the \texttt{Strict-Transport-Security} header.
  \item Configurable via \texttt{config.toml}:
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{security.hsts\_enabled}: Toggle HSTS on/off.
    \item \texttt{security.hsts\_max\_age\_seconds}: Cache duration (default: 31536000 = 1 year).
    \item \texttt{security.hsts\_include\_subdomains}: Apply to all subdomains.
    \item \texttt{security.hsts\_preload}: Enable for HSTS preload list submission.
  \end{itemize}
  \item Example header: \texttt{Strict-Transport-Security: max-age=31536000; includeSubDomains}
  \item Only meaningful when TLS is enabled; browsers ignore HSTS over HTTP.
\end{itemize}

\subsection{Cross-Origin Resource Sharing (CORS)}

CORS policy restricts which origins can access the API:

\begin{itemize}[leftmargin=*,nosep]
  \item Development mode: Allows \texttt{http://localhost:*} origins for local development.
  \item Production mode: Only allows origins specified in \texttt{security.cors\_allowed\_origins}.
  \item Credentials (\texttt{allow\_credentials: true}) enabled for cookie-based authentication.
  \item Allowed methods: GET, POST, PUT, DELETE.
  \item Allowed headers: Content-Type, Authorization.
  \item Exposed headers: Set-Cookie (for session management).
  \item Implementation uses \texttt{tower-http::cors::CorsLayer}.
\end{itemize}

\subsection{Role-Based Access Control}

The application implements a simple role-based access control system:

\begin{itemize}[leftmargin=*,nosep]
  \item Two roles: \texttt{User} (default) and \texttt{Admin}.
  \item Default admin user is created from configuration on first startup (if no users exist in the database).
  \item Admin credentials are configured in \texttt{config.toml} under the \texttt{[admin]} section:
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item \texttt{admin.username}: Admin username.
    \item \texttt{admin.email}: Admin email address.
    \item \texttt{admin.password}: Admin password (should be changed in production).
  \end{itemize}
  \item Admin credentials can be overridden via environment variables with the \texttt{APPSEC\_\_ADMIN\_\_} prefix.
  \item The admin user's email is pre-verified upon creation.
  \item Admin capabilities:
  \begin{itemize}[leftmargin=1.5em,nosep]
    \item View all users.
    \item Change user roles.
    \item Delete users (soft delete).
    \item View and restore deleted posts.
  \end{itemize}
  \item Role stored in \texttt{user\_login.role} column.
  \item Protected endpoints use \texttt{AdminUser} extractor for authorization.
\end{itemize}

\subsection{User Soft Delete}

When an admin deletes a user, the system uses soft delete for security and audit purposes:

\begin{itemize}[leftmargin=*,nosep]
  \item Users are not removed from the database; instead, \texttt{deleted\_at} timestamp is set.
  \item Soft-deleted users cannot log in (authentication queries filter by \texttt{deleted\_at IS NULL}).
  \item Existing sessions of deleted users are invalidated (session validation checks user status).
  \item Posts and comments by deleted users display ``Deleted User'' instead of the username.
  \item This protects against inappropriate usernames remaining visible after account deletion.
  \item Username and email of deleted users remain reserved (prevents re-registration).
  \item Admin user list shows deleted users with visual indication for audit purposes.
  \item API responses include \texttt{isUserDeleted} boolean flag for frontend styling.
\end{itemize}

\subsection{Database Encryption}

Production database uses SQLCipher for at-rest encryption:

\begin{itemize}[leftmargin=*,nosep]
  \item Encryption key sourced from environment variable (\texttt{APPSEC\_DB\_KEY}).
  \item Key must be 64 hex characters (32 bytes).
  \item Falls back to system keyring if environment variable not set.
  \item Development mode uses unencrypted database for easier debugging.
  \item Key format: \texttt{"x'<HEX\_KEY>'"} passed as PRAGMA.
\end{itemize}
\end{newcontent}

\subsection{Anti-Enumeration Measures}

\begin{itemize}[leftmargin=*,nosep]
  \item Password reset always returns 200 OK regardless of email existence.
  \item Login returns generic ``invalid credentials'' for both wrong username and wrong password.
  \item Registration returns specific errors for taken username/email (trade-off for UX).
\end{itemize}

\subsection{Error Handling}

\begin{itemize}[leftmargin=*,nosep]
  \item Typed error codes from \texttt{api-types} crate.
  \item Specific codes for authentication failures.
  \item Validation errors include field-specific details for user feedback.
  \item Internal errors return generic code (HTTP 500).
  \item All error codes translated to user-friendly messages via \texttt{translator} crate.
  \item Stack traces and internal details never exposed to clients.
\end{itemize}

\subsection{Automatic Cleanup}

\begin{itemize}[leftmargin=*,nosep]
  \item Cleanup task runs asynchronously every hour.
  \item Deletes expired email verification tokens.
  \item Deletes expired password reset tokens.
  \item Deletes expired sessions.
  \item Unverified users with expired tokens deleted via CASCADE.
  \item On email sending failure, user record is rolled back immediately.
\end{itemize}

\subsection{Input Validation}

\begin{itemize}[leftmargin=*,nosep]
  \item Dual validation: frontend (WASM) and backend (native Rust).
  \item Same validation logic compiled for both platforms.
  \item Frontend validation for UX; backend is authoritative.
  \item Username: 3--20 characters, printable UTF-8.
  \item Email: Valid format validation.
  \item Password: 8--64 characters, complexity requirements.
\end{itemize}

\subsection{Future Enhancements}

\begin{itemize}[leftmargin=*,nosep]
  \item Rate limiting on login endpoint.
  \item Account lockout after failed attempts.
  \item CAPTCHA integration for bot mitigation.
  \item Device/session management (view and revoke sessions).
  \item Security event logging (failed logins, password resets).
  \item Multi-factor authentication (MFA/2FA).
\end{itemize}
